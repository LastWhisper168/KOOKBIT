# Appendix. Dive into khl.py

khl.py 最近（2021.09）进行了一次重构，重构的原因也很简单：写成屎山了：

循环依赖、命名问题、结构复杂、功能解耦不清晰等等等等。。。

某天晚上我在做一些重复劳动，然后我受不了了：妈耶，半年前的我到底是写了个什么东西？？？

然后我就麻利地开始准备重构了，新版本的设计目标也很简单：

> Rule #1: 好用

用户能够获得和以前一样简洁的接口，甚至可以方便地拓展功能，以方便用户使用

> Rule #2: 好懂

1. 在卫生间就能读完这个文档
2. 读完这个文档后，就能懂 khl.py 的设计方案

所以新设计中，我会引入尽量少的概念，同时保证尽量强的接口能力

废话不多说，开始吧！

# 跟着数据流理解 khl.py

第一部分我会基于数据流来阐述，毕竟数据流就是网络数据包，这是实在的东西，比较好感知（比如打个 log 或者抓个包就能看得见）；同时 khl.py 的本质功能就是对网络数据包的收发与处理

## 数据是怎么进入 khl.py 的

我们可以把 khl.py 想成一个上个世纪的机关大院儿，khl 服务器会给我们这个院发电报（也就是发数据，比如告诉我们哪个服务器有个谁发消息了），所以 khl.py 设计了一个“门卫”专门来负责收发电报：`Gateway`

一个阳光明媚的早上，`Gateway`的接收台(`Receiver`)收到了来自 khl 的电报(被叫做`raw`)，因为电报都是*加密*的，所以`Gateway.Receiver`负需要解密、简单处理电报，以得到普通人能看懂的信(被叫做`pkg`)。然后通过一个传送带(`Gateway.run()` 的参数 `in_queue`，一个队列)把信转交给办事大厅(`Client`)

现在`Client`接收到了这个`pkg`，虽然这封信人类可读，但还是一个字典类型，用起来非常不方便，所以`Client`会贴心地将这封信根据类型转换成`Message`
